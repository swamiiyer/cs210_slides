\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{Analysis of Algorithms}
\date{}

\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Complexity of Algorithms}
\begin{frame}[fragile]
Questions that arise when we write programs that process large amounts of data
\begin{itemize}
\item How long will my program take, ie, what's the \emph{time complexity} of my program?
\item How much memory will my program need, ie, what's the \emph{space complexity} of my program?
\end{itemize}
\end{frame}

\section{Time Complexity}
\begin{frame}[fragile]
Example (3-sum problem)
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class ThreeSum {
    public static int count(int[] a) {
        int N = a.length;
        int cnt = 0;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                for (int k = j + 1; k < N; k++) {
                    if (a[i] + a[j] + a[k] == 0) { 
                        cnt++; 
                    }
                }
            }
        }
        return cnt;
    }
    
    public static void main(String[] args)  { 
        In in = new In(args[0]);
        int[] a = in.readAllInts();
        Stopwatch timer = new Stopwatch();
        int cnt = count(a);
        StdOut.println("elapsed time = " + timer.elapsedTime());
        StdOut.println(cnt);
    } 
}
\end{lstlisting}

\begin{lstlisting}[language={}]
$ java edu.princeton.cs.algs4.ThreeSum 1Kints.txt 
elapsed time = 0.334
70
$ java edu.princeton.cs.algs4.ThreeSum 2Kints.txt 
elapsed time = 2.643
528
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
We can carry out experimental analysis of the running time $T(N)$ of a program using a stopwatch, where $N$ is the input size

\bigskip

\lstinline{Stopwatch} API
\begin{center}
\begin{tabular}{cc}
method & description \\ \hline
\lstinline$Stopwatch()$ & creates a stopwatch \\
\lstinline$double elapsedTime()$ & returns elapsed time since creation
\end{tabular} 
\end{center}

\bigskip

\lstinline{Stopwatch} implementation
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class Stopwatch {
    private final long start;
    
    public Stopwatch() { 
        start = System.currentTimeMillis(); 
    }
    
    public double elapsedTime() {
        return (System.currentTimeMillis() - start) / 1000.0;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
A \lstinline{Stopwatch} client that produces experimental data for \lstinline{ThreeSum}
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class DoublingTest {
    public static double timeTrial(int N) {
        int MAX = 1000000;
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = StdRandom.uniform(-MAX, MAX);
        }
        Stopwatch timer = new Stopwatch();
        ThreeSum.count(a);
        return timer.elapsedTime();
    }

    public static void main(String[] args) { 
        for (int N = 250; true; N += N) {
            double time = timeTrial(N);
            StdOut.printf("%7d %5.1f\n", N, time);
        } 
    } 
} 
\end{lstlisting}

\begin{lstlisting}[language={}]
$ java edu.princeton.cs.algs4.DoublingTest
    250   0.0
    500   0.0
   1000   0.1
   2000   0.8
   4000   6.4
   8000  51.1
    ...   ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Plots of the experimental data 
\begin{center}
\includegraphics[scale=0.4]{{./figures/threesum}.pdf}
\end{center}

From the log-log plot we have $$\lg T(N) = 3\lg N + \lg a,$$ where $a$ is a constant

$$\therefore \text{\ \ \ \ } T(N)=aN^3$$ 
and since $T(8000)=51.1$, we have $$T(N)=9.98\times 10^{-11}N^3$$
\end{frame}

\begin{frame}[fragile]
We can also derive a mathematical expression for the running time $T(N)$ of a program

\bigskip

The total running time of a program is determined by: the cost of executing each statement (property of the computer); and the frequency of execution of each statement (property of the program and the input)

\bigskip

We write $\sim f(N)$ (called \emph{tilde approximation}) to represent any function that, when divided by $f(N)$, approaches 1 as $N$ grows, and we write $g(N)\sim f(N)$ to indicate that $g(N)/f(N)$ approaches 1 as $N$ grows

\bigskip

Most often, we work with tilde approximations of the form $g(N)\sim af(N)$ where $f(N)=N^b(\log N)^c$ with $a, b$, and $c$ constants and refer to $f(N)$ as the \emph{order of growth} of $g(N)$
\end{frame}

\begin{frame}[fragile]
Analyzing the running time of \lstinline{ThreeSum.count()}
\begin{lstlisting}[language=Java, mathescape]
public static int count(int[] a) {
    int N = a.length;                           $[A]$
    int cnt = 0;
    for (int i = 0; i < N; i++) {               $[B]$ 
        for (int j = i + 1; j < N; j++) {       $[C]$
            for (int k = j + 1; k < N; k++) {   $[D]$
                if (a[i] + a[j] + a[k] == 0) {
                    cnt++;                      $[E]$
                }
            }
        }
    }
    return cnt;
}
\end{lstlisting}
\begin{center}
\begin{tabular}{cccc}
statement block & time & frequency & total time\\ \hline \\
$[E]$ & $t_0$ & $x$ (depends on input) & $t_0x$ \\
$[D]$ & $t_1$ & $N^3/6-N^2/2+N/3$  & $t_1(N^3/6-N^2/2+N/3)$ \\
$[C]$ & $t_2$ & $N^2/2-N/2$  & $t_2(N^2/2-N/2)$ \\
$[B]$ & $t_3$ & $N$  & $t_3N$ \\
$[A]$ & $t_4$ & $1$  & $t_4$ 
\end{tabular} 
\end{center}
Grand total: $(t_1/6)N^3+(t_2/2-t_1/2)N^2+(t_1/3-t_2/2+t_3)N+t_4+t_0x$

\smallskip

Tilde approximation: $\sim(t_1/6)N^3$ (assuming $x$ is small)

\smallskip

Order of growth: $N^3$
\end{frame}

\begin{frame}[fragile]
For many programs, developing a mathematical model of running time reduces to the following steps
\begin{itemize}
\item Develop an input model, including a definition of the problem size
\item Identify the inner loop
\item Define a cost model that includes operations in the inner loop
\item Determine the frequency of execution of those operations for the given input
\end{itemize}

\bigskip

For \lstinline{ThreeSum}, the input model is $N$ numbers; the inner loop is the statements in a triply nested \lstinline{for} loop; the cost model is the number of array accesses; and the number of array accesses is $N^3/2$
\end{frame}

\begin{frame}[fragile]
Order-of-growth classifications
\begin{center}
\begin{tabular}{cccc}
description & function & code description & example \\ \hline \\
constant & 1 & statement & add two numbers \\
logarithmic & $\log N$ & divide in half & binary search \\
linear & $N$ & loop & find the maximum \\
linearithmic & $N\log N$ & divide and conquer & merge sort \\
quadratic & $N^2$ & double loop & check all pairs \\
cubic & $N^3$ & triple loop & check all triples \\
exponential & $2^N$ & exhaustive search & check all subsets
\end{tabular} 
\end{center}

\smallskip

\begin{center}
\includegraphics[scale=0.47]{{./figures/order_of_growth}.pdf}
\end{center}
\end{frame}

\begin{frame}[fragile]
Predictions on the basis of order-of-growth functions for a program that takes a few hours for input of size $N$
\begin{center}
\begin{tabular}{ccccc}
description & function & $2x$ factor & $10N$ & $10N$ on $10x$ CPU\\ \hline \\
linear & $N$ & 2 & a day & a few hours \\
linearithmic & $N\log N$ & 2 & a day & a few hours \\
quadratic & $N^2$ & 4 & a few weeks & a day \\
cubic & $N^3$ & 8 & several months & a few weeks \\
exponential & $2^N$ & $2^N$ & never & never
\end{tabular} 
\end{center}
\end{frame}

\begin{frame}[fragile]
Search problem: search for a key in a collection of $N$ keys

\bigskip

Linear search
\begin{lstlisting}[language=Java]
public static int indexOf(int[] a, int key) {
    for (int i = 0; i < a.length; i++) {
        if (a[i] == key) { 
            return i; 
        }
    }
    return -1;
}
\end{lstlisting}

Order of growth: $N$

\bigskip

Binary search
\begin{center}
\includegraphics[scale=0.65]{./figures/bs1.pdf}

\smallskip

successful search for the key 23
\end{center}
\end{frame}

\begin{frame}[fragile]
\begin{center}
\includegraphics[scale=0.65]{./figures/bs2.pdf}

\smallskip

unsuccessful search for the key 50
\end{center}
\end{frame}

\begin{frame}[fragile]
Binary search and whitelisting

\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class BinarySearch {
    public static int indexOf(int[] a, int key) {
        int lo = 0;
        int hi = a.length - 1;
        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;
            if      (key < a[mid]) { hi = mid - 1; }
            else if (key > a[mid]) { lo = mid + 1; }
            else { return mid; }
        }
        return -1;
    }

    public static void main(String[] args) {
        In in = new In(args[0]);
        int[] whitelist = in.readAllInts();
        Arrays.sort(whitelist);
        while (!StdIn.isEmpty()) {
            int key = StdIn.readInt();
            if (BinarySearch.indexOf(whitelist, key) == -1) {
                StdOut.println(key);
            }
        }
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language={}]
tinyW.txt tinyT.txt
   84        23
   48        50
   68        10
   10        99
   18        18
   98        23
   12        98
   23        84
   54        11
   57        10
   48        48
   33        77
   16        13
   77        54
   11        98
   29        77
             77
             68
\end{lstlisting}

\begin{lstlisting}[language={}]
$ java edu.princeton.cs.algs4.BinarySearch tinyW.txt < tinyT.txt
50
99
13
\end{lstlisting}

Binary search order of growth: $\lg N + 1$ 

\bigskip

Whitelisting order of growth: $M(\lg N + 1)$, where $M$ is the number of calls to \lstinline{BinarySearch.indexOf()}
\end{frame}

\begin{frame}[fragile]
Faster solution to the 3-sum problem
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

import java.util.Arrays;

public class ThreeSumFast {
    public static int count(int[] a) {
        int N = a.length;
        Arrays.sort(a);
        int cnt = 0;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                if (BinarySearch.indexOf(a, -a[i] - a[j]) > j) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
    
    public static void main(String[] args) {
        In in = new In(args[0]);
        int[] a = in.readAllInts();
        int cnt = count(a);
        StdOut.println(cnt);
    }
}
\end{lstlisting}

Order of growth: $N^2\log N$
\end{frame}

\begin{frame}[fragile]
Caveats
\begin{itemize}
\item With leading-term approximations, we ignore constant coefficients in lower-order terms, which may not be justifed

\item The assumption that the inner loop dominates may not always be correct 

\item The assumption that each instruction always takes the same amount of time is not always correct

\item Typically, there are many things going on in your computer and these can affect the reproducibility of experiments

\item Often, when we compare two different programs for the same task, one might be faster in some situations, and slower in others

\item When running time is sensitive to inputs, we may get inconsistent results or be unable to validate our hypotheses

\item We have been focusing on measuring performance as a function of a single parameter, generally the size of the input, but it is not unusual to have several parameters
\end{itemize}
\end{frame}

\begin{frame}[fragile]
Coping with dependence on inputs
\begin{itemize}
\item Carefully model the kind of input to be processed in the problems that we need to solve

\item Take an extremely pessimistic view of the performance of algorithms, and seek the running time in the worst case

\item An important way to provide a performance guarantee is to introduce randomness

\item For many applications, the algorithm ``input'' might be not just data, but the sequence of operations performed by the client

\item Amortize the cost by keeping track of the total cost of all operations, divided by the number of operations
\end{itemize}
\end{frame}

\section{Space Complexity}
\begin{frame}[fragile]
Memory requirements for primitive types
\begin{center}
\begin{tabular}{cc}
type & bytes \\ \hline \\
\lstinline$boolean$ & 1 \\
\lstinline$byte$ & 1 \\
\lstinline$char$ & 2 \\
\lstinline$int$ & 4 \\
\lstinline$float$ & 4 \\
\lstinline$long$ & 8 \\
\lstinline$double$ & 8
\end{tabular} 
\end{center}

\bigskip

To determine the memory usage of an object, we add the amount of memory used by each instance variable to the overhead associated with each object, which is 16 bytes

\bigskip

A \lstinline{Counter} object uses 32 bytes: 16 bytes of overhead, 8 bytes for its \lstinline{String} instance variable (a reference), 4 bytes for its \lstinline{int} instance variable, and 4 bytes of padding

\bigskip

A nested non-static (inner) class requires an extra 8 bytes of overhead (for reference to the enclosing instance)
\end{frame}

\begin{frame}[fragile]
An array of primitive-type values typically requires 24 bytes of header information (16 bytes of object overhead, 4 bytes for the length, and 4 bytes of padding) plus the memory needed to store the values

\bigskip

For example, an array of $N$ \lstinline{int} values uses $24 + 4N$ bytes 

\bigskip

An array of objects is an array of references to objects, so we need to add the space for the references to the space required for the objects

\bigskip

For example, an array of $N$ \lstinline{Date} objects uses 24 bytes (array overhead) plus $8N$ bytes (references) plus 32 bytes for each object, for a grand total of $24+40N$ bytes

\bigskip

A two-dimensional array is an array of arrays (each array is an object)

\bigskip

For example, a two-dimensional $M$-by-$N$ array of \lstinline{double} values uses 24 bytes (overhead for array of arrays) plus $8M$ bytes (references to the row arrays) plus $24M$ bytes (overhead from the row arrays) plus $8MN$ bytes (for the $N$ \lstinline{double} values in each of the $M$ rows) for a grand total of $8MN+32M+24\sim 8MN$ bytes

\bigskip

A \lstinline{String} of length $N$ typically uses 32 bytes (for the \lstinline{String} object) plus $24+2N$ bytes (for the array that contains the characters) for a total of $56+2N$ bytes
\end{frame}
\end{document}
