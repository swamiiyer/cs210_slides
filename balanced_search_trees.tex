\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{Balanced Search Trees}
\date{}

\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{2-3 Search Trees}
\begin{frame}[fragile]
A \emph{2-3 search tree} is a tree that is either empty (null link) or
\begin{itemize}
\item A 2-node with one key (and associated value) and two links, a left link to a 2-3 search tree with smaller keys, and a right link to a 2-3 search tree with larger keys

\item A 3-node with two keys (and associated values) and three links, a left link to a 2-3 search tree with smaller keys, a middle link to a 2-3 search tree with keys between the node's keys, and a right link to a 2-3 search tree with larger keys
\end{itemize}

\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree}.png}
\end{center}

\bigskip

A 2-3 search tree has \emph{symmetric order} --- inorder traversal yields keys in ascending order

\bigskip

A \emph{perfectly balanced 2-3 search tree} is one whose null links are all the same distance from the root

\begin{center}
\includegraphics[scale=0.3]{{./figures/23_tree_perfect_balance}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Searching for a key in a 2-3 tree
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_search}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Inserting a key into a 2-node
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_insert1}.png}
\end{center}

\bigskip

Inserting a key into a single 3-node
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_insert2}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Inserting a key into a 3-node whose parent is a 2-node
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_insert3}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Inserting a key into a 3-node whose parent is a 3-node
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_insert4}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Splitting the root
\begin{center}
\includegraphics[scale=0.4]{{./figures/23_tree_insert5}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Splitting a 4-node is a local transformation: constant number of operations

\bigskip

Insert operation maintains symmetric order and perfect balance

\bigskip

Tree height
\begin{itemize}
\item Worst case: $\lg N$ (all 2-nodes)

\item Best case: $\log_3 N \approx 0.631 \lg N$ (all 3-nodes)

\item Between 12 and 20 for a million nodes

\item Between 18 and 30 for a billion nodes
\end{itemize}

\bigskip

Guaranteed logarithmic performance for search and insert
\end{frame}

\begin{frame}[fragile]
Direct implementation is complicated because
\begin{itemize}
\item Maintaining multiple node types is cumbersome

\item Need multiple comparisons to move down tree

\item Need to move back up the tree to split 4-nodes

\item Large number of cases for splitting
\end{itemize}

\bigskip

Fantasy code
\begin{lstlisting}[language=Java]
public void put(Key key, Value val) {
    Node x = root;
    while (x.getTheCorrectChild(key) != null) {
        x = x.getTheCorrectChildKey();
        if (x.is4Node()) { x.split(); }
    }
    if (x.is2Node()) { x.make3Node(key, val); }
    else if (x.is3Node()) { x.make4Node(key, val); }
}
\end{lstlisting}

\bigskip

Could do it, but there's a better way (use red-black BSTs)
\end{frame}

\section{Red-Black BSTs}
\begin{frame}[fragile]
We represent a 2-3 tree as a BST, using ``internal'' left-leaning links as ``glue'' for 3-nodes

\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst1}.png}
\end{center}

\bigskip

A \emph{red-black tree} is a BST such that
\begin{itemize}
\item No node has two red links connected to it

\item Every path from root to null link has the same number of black links (perfect black balance)

\item Red links lean left
\end{itemize}

\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst2}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
One-to-one correspondence between red-black BSTs and 2-3 trees

\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst3}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Red-black BST representation: each node is pointed to by precisely one link (from its parent) $\implies$ can encode color of links in nodes

\begin{minipage}{180pt}
\begin{lstlisting}[language=Java]
private static final boolean RED   = true;
private static final boolean BLACK = false;

private class Node {
    private Key key;
    private Value val;
    private Node left, right; 
    private boolean color; 
    private int N;

    public Node(Key key, Value val, 
                boolean color, int N) {
        this.key = key;
        this.val = val;
        this.color = color;
        this.N = N;
    }
}
    
private boolean isRed(Node x) {
    if (x == null) { return false };
    return x.color == RED;
}
\end{lstlisting}
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst4}.png}
\end{center}
\end{minipage}
\end{frame}

\section{Elementary Red-black BST Operations}
\begin{frame}[fragile]
Elementary red-black BST operations (left/right rotation and color flip) maintain symmetric order and perfect black balance

\bigskip

Left rotation: orient a (temporarily) right-leaning red link to lean left
\begin{minipage}{170pt}
\begin{lstlisting}[language=Java]
private Node rotateLeft(Node h) {
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = x.left.color;
    x.left.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}
\end{lstlisting}
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst5}.png}

\smallskip

Rotate E left (before)
\end{center}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst6}.png}

\smallskip

Rotate E left (after)
\end{center}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
Right rotation: orient a left-leaning red link to (temporarily) lean right
\begin{minipage}{170pt}
\begin{lstlisting}[language=Java]
private Node rotateRight(Node h) {
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = x.right.color;
    x.right.color = RED;
    x.N = h.N;
    h.N = size(h.left) + size(h.right) + 1;
    return x;
}
\end{lstlisting}
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst7}.png}

\smallskip

Rotate S right (before)
\end{center}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst8}.png}

\smallskip

Rotate S right (after)
\end{center}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
Color flip: recolor to split a (temporary) 4-node
\begin{minipage}{170pt}
\begin{lstlisting}[language=Java]
private void flipColors(Node h) {
    h.color = !h.color;
    h.left.color = !h.left.color;
    h.right.color = !h.right.color;
}
\end{lstlisting}
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst9}.png}

\smallskip

Flip colors (before)
\end{center}
\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst10}.png}

\smallskip

Flip colors (after)
\end{center}
\end{minipage}
\end{frame}

\section{Implementation of the Ordered Symbol Table API Using a Red-Black BST}
\begin{frame}[fragile]
Most operations are the same as for BST-based implementation --- ignore color

\bigskip

Insertion: the basic strategy is to maintain 1-1 correspondence with 2-3 trees, using the elementary red-black BST operations (left/right rotation and color flip) to maintain symmetric order and perfect balance, but not necessarily color invariants

\bigskip

Case 1 (insert into a 2-node at the bottom): do standard BST insert; color new link red; if new red link is a right link, rotate left

\begin{center}
\includegraphics[scale=0.4]{{./figures/red_black_bst11}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
Case 2 (insert into a 3-node at the bottom): do standard BST insert; color new link red; rotate to balance the 4-node (if needed); flip colors to pass red link up one level; rotate to make lean left (if needed); repeat case 1 or case 2 up the tree (if needed)

\begin{center}
\includegraphics[scale=0.32]{{./figures/red_black_bst12}.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
\begin{minipage}{150pt}
Implementation (same code for all cases)
\begin{itemize}
\item Right child red, left child black: rotate left

\item Left child, left-left grandchild red: rotate right

\item Both children red: flip colors
\end{itemize}
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.3]{{./figures/red_black_bst13}.png}
\end{center}
\end{minipage}
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

import java.util.NoSuchElementException;

public class BST<Key extends Comparable<Key>, Value> {
    private Node root;
    ...
    public void put(Key key, Value val) {
        root = put(root, key, val); root.color = BLACK;
    }

    private Node put(Node h, Key key, Value val) { 
        if (h == null) { return new Node(key, val, RED, 1); }
        int cmp = key.compareTo(h.key);
        if      (cmp < 0) { h.left  = put(h.left,  key, val); }
        else if (cmp > 0) { h.right = put(h.right, key, val); }
        else              { h.val   = val; }
        if (isRed(h.right) && !isRed(h.left))      { h = rotateLeft(h); }
        if (isRed(h.left)  &&  isRed(h.left.left)) { h = rotateRight(h); }
        if (isRed(h.left)  &&  isRed(h.right))     { flipColors(h); }
        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
    ...
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Deletion: see exercises 3.3.39 -- 3.3.41

\bigskip

The height of a red-black BST with $N$ nodes is no more than $2 \lg N$; the average length of a path from the root to a node in a red-black BST with $N$ nodes is $\sim \lg N$

\begin{center}
\includegraphics[scale=0.35]{{./figures/red_black_bst14}.png}

\smallskip

\small Typical red-black BST built from random keys (null links omitted)
\end{center}

\begin{center}
\includegraphics[scale=0.35]{{./figures/red_black_bst15}.png}

\smallskip

\small Red-black BST built from ascending keys (null links omitted)
\end{center}
\end{frame}

\section{Performance Characteristics}
\begin{frame}[fragile]
Symbol table operations summary

\begin{center}
\begin{tabular}{ccc}
operation & BST & red-black BST \\ \hline \\
search & $h^\dagger$ & $2\lg N$ \\
insert & $h$ & $2\lg N$ \\
delete & $N^{\dagger\dagger}$ & $2\lg N$ \\
min/max & $h$ & $2\lg N$ \\
floor/ceiling & $h$ & $2\lg N$ \\
rank & $h$ & $2\lg N$ \\
select & $h$ & $2\lg N$ \\
ordered iteration & $N$ & $N$ 
\end{tabular}

\bigskip

\tiny $\dagger$ $h$ is the height of BST, proportional to $\lg N$ if keys inserted in random order

$\dagger\dagger$ $\sqrt{N}$ in the average case; other operations also become $\sqrt{N}$ if deletions are allowed
\end{center} 
\end{frame}
\end{document}
