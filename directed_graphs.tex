\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{Directed Graphs}
\date{}
\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{Directed Graphs}
\begin{frame}[fragile]
\begin{minipage}{200pt}
A \emph{directed graph} (\emph{digraph}) is a set of vertices and a collection of directed edges, each connecting an ordered pair of vertices

\bigskip

The \emph{outdegree} of a vertex in a digraph is the number of edges
going from it; the \emph{indegree} of a vertex is the number of edges going to it

\bigskip

A \emph{directed path} in a digraph is a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence

\bigskip

A \emph{directed cycle} is a directed path with at least one edge whose first and last vertices are the same

\bigskip

The \emph{length} of a path or a cycle is its number of edges
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.45]{{./figures/digraph1}.png}

\tiny anatomy of a digraph
\end{center}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
Digraph applications
\begin{center}
\begin{tabular}{ccc}
digraph & vertex & edge \\ \hline \\
transportation & street intersection & one-way street \\
web & web page & hyperlink \\
food web & species & predator-prey relationship \\
WordNet & synset & hypernym \\
scheduling & task & precedence constraint \\
financial & bank & transaction \\
cell phone & person & placed call \\
infectious disease & person & infection \\
game & board position & legal move \\
citation & journal article & citation \\
object graph & object & pointer \\
inheritance hierarchy & class & inherits from \\ 
control flow & code block & jump
\end{tabular}  
\end{center}
\end{frame}

\begin{frame}[fragile]
Some digraph problems
\begin{center}
\begin{tabular}{cp{5cm}}
problem & description \\ \hline \\
$s\to t$ path & is there a path from $s$ to $t$? \\ 
shortest $s\to t$ path & what is the shortest path from $s$ to $t$? \\
directed cycle & is there a directed cycle in the graph? \\
topological sort & can the digraph be drawn so that all edges point in a single direction? \\
strong connectivity & is there a directed path between all pairs of vertices? \\
transitive closure & for which vertices $v$ and $w$ is there a directed path from $v$ to $w$? \\
PageRank & what is the importance of a web page?
\end{tabular}  
\end{center}
\end{frame}

\begin{frame}[fragile]
Digraph API

\begin{center}
\begin{tabular}{cc}
method & description \\ \hline
\lstinline$Digraph(int V)$ & creates an empty digraph with $V$ vertices \\
\lstinline$Digraph(In in)$ & creates a digraph from input stream \\
\lstinline$void addEdge(int v, int w)$ & adds a directed edge $v \to w$ \\
\lstinline$Iterable<Integer> adj(int v)$ & vertices pointing from $v$ \\
\lstinline$int V()$ & number of vertices \\
\lstinline$int E()$ & number of edges \\
\lstinline$Digraph reverse()$ & reverse of this digraph
\end{tabular} 
\end{center}

Graph input format
\begin{minipage}{150pt}
\begin{lstlisting}[language={}]
$ more tinyDG.txt
13 22 
4 2 2 3 3 2 6 0 0 1 2 0 11 12 12 9
9 10 9 11 8 9 10 12 11 4 4 3 3 5
7 8 8 7 5 4 0 5 6 4 6 9 7 6
\end{lstlisting}
\end{minipage}%
\begin{minipage}{150pt}
\begin{center}
\includegraphics[scale=0.5]{{./figures/digraph2}.png}
\end{center}
\end{minipage}

\bigskip

Typical graph-processing code
\begin{lstlisting}[language=Java]
In in = new In(args[0]);
Digraph G = new Digraph(in);
for (int v = 0; v < G.V(); v++) {
    for (int w : G.adj(v)) {
        StdOut.println(v + "->" + w);
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Digraph {
    private final int V;
    private int E;
    private LinkedBag<Integer>[] adj;

    public Digraph(int V) {
        if (V < 0) { throw new IllegalArgumentException(...); }
        this.V = V;
        this.E = 0;
        adj = (LinkedBag<Integer>[]) new LinkedBag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new LinkedBag<Integer>();
        }
    }

    public Digraph(In in) {
        this.V = in.readInt();
        if (V < 0) { throw new IllegalArgumentException(...); }
        adj = (LinkedBag<Integer>[]) new LinkedBag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new LinkedBag<Integer>();
        }
        int E = in.readInt();
        if (E < 0) { throw new IllegalArgumentException(...); }
        for (int i = 0; i < E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            addEdge(v, w); 
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language=Java]
    public int V() { return V; }

    public int E() { return E; }

    private void validateVertex(int v) {
        if (v < 0 || v >= V) { throw new IndexOutOfBoundsException(...); }
    }

    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        adj[v].add(w);
        E++;
    }

    public Iterable<Integer> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    public Digraph reverse() {
        Digraph R = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                R.addEdge(w, v);
            }
        }
        return R;
    }
    ...
}
\end{lstlisting}
\end{frame}

\section{Depth-First Search (DFS)}
\begin{frame}[fragile]
Same method as for undirected graphs, ie, to visit a vertex $v$
\begin{itemize}
\item Mark a vertex $v$ as visited

\item Recursively visit all unmarked vertices pointing from $v$
\end{itemize}

\bigskip

Reachability problem
\begin{itemize}
\item Single-source reachability: given a digraph and a source vertex $s$, support queries of the form \emph{is there a directed path from $s$ to a given target vertex $v$?}

\item Multi-source reachability: given a digraph and a set of source vertices, support queries of the form \emph{is there a directed path from any vertex in the set to a given target vertex $v$?}
\end{itemize}

\bigskip

Applications
\begin{itemize}
\item Program control-flow analysis such as dead-code elimination and  infinite-loop detection

\item Mark and sweep garbage collector
\end{itemize}
\end{frame}

\section{Breadth-First Search (BFS)}
\begin{frame}[fragile]
Same method as for undirected graphs, ie, repeat until queue is empty
\begin{itemize}
\item Remove vertex $v$ from queue

\item Add to queue all unmarked vertices pointing from $v$ and mark them
\end{itemize}

\bigskip

BFS computes shortest paths (fewest number of edges)
from source vertex $s$ to all other vertices in a digraph in time proportional to $E + V$

\bigskip

Multiple-source shortest paths: given a digraph and a set of source vertices, find shortest path from any vertex in the set to each other vertex; solution: use BFS, but initialize by enqueuing all source vertices
\end{frame}

\begin{frame}[fragile]
Application (web crawler)
\begin{lstlisting}[language=Java]
import edu.princeton.cs.algs4.*;
import java.util.regex.*;

public class WebCrawler { 
    public static void main(String[] args) { 
        String s = args[0];
        LinkedQueue<String> queue = new LinkedQueue<String>();
        queue.enqueue(s);
        SET<String> marked = new SET<String>();
        marked.add(s);
        while (!queue.isEmpty()) {
            String v = queue.dequeue();
            System.out.println(v);
            In in = new In(v);
            if (!in.exists()) { continue; }
            String input = in.readAll();
            if (input == null) { continue; }
            String regexp = "http://(\\w+\\.)+(\\w+)";
            Pattern pattern = Pattern.compile(regexp);
            Matcher matcher = pattern.matcher(input);
            while (matcher.find()) {
                String w = matcher.group();
                if (!marked.contains(w)) { queue.enqueue(w); marked.add(w); }
            }
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[language={}]
$ java WebCrawler http://www.swamiiyer.net/
http://www.swamiiyer.net/
http://www.w3.org
http://jemdoc.jaboc.net
...
\end{lstlisting}
\end{frame}

\section{Topological Sort}
\begin{frame}[fragile]
Precedence-constrained scheduling: given a set of jobs to be completed, with precedence constraints that specify that certain jobs have to be completed before certain other jobs are begun, how can we schedule the jobs such that they are all completed while still respecting the constraints?

\begin{center}
\includegraphics[scale=0.4]{{./figures/digraph3}.png}

\smallskip

\small a precedence-constrained scheduling problem

\includegraphics[scale=0.4]{{./figures/digraph4}.png}

\smallskip

\small standard digraph model
\end{center}
\end{frame}

\begin{frame}[fragile]
Topological sort: given a DAG (a directed acyclic graph), put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order

\begin{center}
\includegraphics[scale=0.35]{{./figures/digraph5}.png}
\end{center}

\bigskip

A digraph has a topological order if and only if it is a DAG
\end{frame}

\begin{frame}[fragile]
Directed cycle detection (see \lstinline{DirectedCycle}) applications
\begin{itemize}
\item Cyclic inheritance

\item Circular references in spreadsheet calculations
\end{itemize}

\bigskip

Depth-first search orders (see \lstinline{DepthFirstOrder})
\begin{itemize}
\item Preorder: order in which \lstinline{dfs()} is called

\item Postorder: order in which \lstinline{dfs()} returns

\item Reverse postorder: reverse order in which \lstinline{dfs()} returns
\end{itemize}

\begin{lstlisting}[language=Java]
private void dfs(Graph G, int v) {
    marked[v] = true;
    preorder.enqueue(v);
    for (int w : G.adj(v)) {
        if (!marked[w]) { dfs(G, w); }
    }
    postorder.enqueue(v);
    reversePostorder.push(v);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Topological sort (solution)
\begin{itemize}
\item Run depth-first search

\item Return vertices in reverse postorder
\end{itemize}

\bigskip

Topological sort (implementation)
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class Topological {
    private Iterable<Integer> order; 

    public Topological(Digraph G) {
        DirectedCycle finder = new DirectedCycle(G);
        if (!finder.hasCycle()) {
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversePost();
        }
    }
    
    public Iterable<Integer> order() { return order; }

    public boolean hasOrder() { return order != null; }
    ...
}
\end{lstlisting}
\end{frame}

\section{Strong Components}
\begin{frame}[fragile]
Vertices $v$ and $w$ are \emph{strongly connected} if there is both a directed path from $v$ to $w$ and a directed path from $w$ to $v$

\begin{center}
\includegraphics[scale=0.3]{{./figures/digraph6}.png}

\smallskip

\small strongly connected digraphs
\end{center}

A strong component is a maximal subset of strongly-connected vertices

\begin{center}
\includegraphics[scale=0.3]{{./figures/digraph7}.png}

\smallskip

\small a digraph and its strong components
\end{center}

Applications
\begin{itemize}
\item Ecological food web

\item Software module dependency
\end{itemize}
\end{frame}

\begin{frame}[fragile]
Computing strong components (solution: Kosaraju-Sharir algorithm)
\begin{itemize}
\item Given a digraph $G$, use \lstinline{DepthFirstOrder} to compute the reverse postorder of its reverse, $G^R$

\item Run standard DFS on $G$, but consider the unmarked vertices in the order just computed instead of the standard numerical order

\item All vertices reached on a call to the recursive \lstinline{dfs()} from the constructor are in a strong component, so identify them as in \lstinline{CC}
\end{itemize}

\bigskip

Kosaraju-Sharir algorithm (implementation)
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class KosarajuSharirSCC {
    ...
    public KosarajuSharirSCC(Digraph G) {
        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v : dfs.reversePost()) {
            if (!marked[v]) { dfs(G, v); count++; }
        }
    }
    
    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) { dfs(G, w); }
        }
    }
    ...
}
\end{lstlisting}
\end{frame}
\end{document}
