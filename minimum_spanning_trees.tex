\documentclass[8pt,a4paper,compress]{beamer}

\usepackage{/home/siyer/lib/slides}

\title{Minimum Spanning Trees}
\date{}
\begin{document}
\begin{frame}
\vfill
\titlepage
\end{frame}

\begin{frame}
\frametitle{Outline}
\tableofcontents
\end{frame}

\section{What are Minimum Spanning Trees?}
\begin{frame}[fragile]
A spanning tree of a graph is a connected subgraph with no cycles that includes all the vertices

\bigskip

A minimum spanning tree (MST) of an edge-weighted undirected graph is a spanning tree whose weight (the sum of the weights of its edges) is no larger than the weight of any other spanning tree

\begin{center}
\includegraphics[scale=0.4]{./figures/mst1.png}

\smallskip

\tiny an edge-weighted graph and its MST
\end{center}

If the graph is connected and the edge weights are unique, then MST exists and is unique

\bigskip

Goal: given a connected undirected graph $G$ with arbitrary (but distinct) edge weights, find the MST of $G$
\end{frame}

\begin{frame}[fragile]
Typical MST applications

\begin{center}
\begin{tabular}{ccc}
application & vertex & edge \\ \hline \\
circuit & component & wire \\
airline & airport & flight route \\
power distribution & power plant & transmission lines \\
image analysis & feature & proximity relationship
\end{tabular}
\end{center}
\end{frame}

\section{Edge-Weighted Graph API}
\begin{frame}[fragile]
Weighted-edge data type (API)
\begin{center}
\begin{tabular}{cc}
method & description \\ \hline \\
\lstinline$Edge(int v, int w, double weight)$ & create a weighted edge $v$-$w$ \\
\lstinline$double weight()$ & edge weight \\
\lstinline$int either()$ & either endpoint \\
\lstinline$int other(int v)$ & the endpoint that's not $v$
\end{tabular}  
\end{center}
\end{frame}

\begin{frame}[fragile]
Weighted-edge data type (Implementation)
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class Edge implements Comparable<Edge> {
    private final int v, w;
    private final double weight;

    public Edge(int v, int w, double weight) {
        if (v < 0 || w < 0) { throw new IndexOutOfBoundsException(); }
        if (Double.isNaN(weight)) { throw new IllegalArgumentException(); }
        this.v = v; this.w = w; this.weight = weight;
    }

    public double weight() { return weight; }

    public int either() { return v; }

    public int other(int vertex) {
        if      (vertex == v) { return w; }
        else if (vertex == w) { return v; }
        else { throw new IllegalArgumentException(); }
    }

    public int compareTo(Edge that) {
        if      (this.weight() < that.weight()) { return -1; }
        else if (this.weight() > that.weight()) { return +1; }
        else                                    { return  0; }
    }
    ...
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
Edge-weighted graph (API)

\begin{center}
\begin{tabular}{cc}
method & description \\ \hline \\
\lstinline$EdgeWeightedGraph(int V)$ & create an empty graph with $V$ vertices \\
\lstinline$EdgeWeightedGraph(In in)$ & create a graph from input stream \\
\lstinline$int V()$ & number of vertices  \\
\lstinline$int E()$ & number of edges \\
\lstinline$void addEdge(Edge e)$ & add weighted edge $e$ to this graph \\
\lstinline$Iterable<Edge> adj(int v)$ & edges incident to $v$ \\
\lstinline$Iterable<Edge> edges()$ & all edges in this graph
\end{tabular}  
\end{center}
\end{frame}

\begin{frame}[fragile]
Edge-weighted graph (implementation)
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class EdgeWeightedGraph {
    private final int V;
    private int E;
    private LinkedBag<Edge>[] adj;
    
    public EdgeWeightedGraph(int V) {
        if (V < 0) { throw new IllegalArgumentException(); }
        this.V = V;
        this.E = 0;
        adj = (LinkedBag<Edge>[]) new LinkedBag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new LinkedBag<Edge>();
        }
    }

    public EdgeWeightedGraph(In in) {
        this(in.readInt());
        int E = in.readInt();
        if (E < 0) { throw new IllegalArgumentException(); }
        for (int i = 0; i < E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            double weight = in.readDouble();
            Edge e = new Edge(v, w, weight);
            addEdge(e);
        }
    }
    
    public int V() { return V; }

    public int E() { return E; }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language=Java]
    public void addEdge(Edge e) {
        int v = e.either();
        int w = e.other(v);
        validateVertex(v);
        validateVertex(w);
        adj[v].add(e);
        adj[w].add(e);
        E++;
    }

    public Iterable<Edge> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    public Iterable<Edge> edges() {
        LinkedBag<Edge> list = new LinkedBag<Edge>();
        for (int v = 0; v < V; v++) {
            int selfLoops = 0;
            for (Edge e : adj(v)) {
                if (e.other(v) > v) { list.add(e); }
                else if (e.other(v) == v) {
                    if (selfLoops % 2 == 0) { list.add(e); }
                    selfLoops++;
                }
            }
        }
        return list;
    }
    ...
}
\end{lstlisting}
\end{frame}

\section{Minimum Spanning Tree API}
\begin{frame}[fragile]
MST API
\begin{center}
\begin{tabular}{cc}
method & description \\ \hline \\
\lstinline$MST(EdgeWeightedGraph G)$ & constructor \\
\lstinline$Iterable<Edge> edges()$ & all of the MST edges \\
\lstinline$double weight()$ & weight of MST
\end{tabular}  
\end{center}

MST test client
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class KruskalMST {
    ...
    public static void main(String[] args) {
        In in = new In(args[0]);
        EdgeWeightedGraph G = new EdgeWeightedGraph(in);
        MST mst = new MST(G);
        for (Edge e : mst.edges()) { 
            StdOut.println(e);
        }
        StdOut.println(mst.weight());
    }
    ...
}
\end{lstlisting}

\begin{lstlisting}[language={}]
$ java edu.princeton.cs.algs4.KruskalMST tinyEWG.txt
0-7 0.16
1-7 0.19
0-2 0.26
2-3 0.17
5-7 0.28
4-5 0.35
6-2 0.40
1.81
\end{lstlisting}
\end{frame}

\section{Greedy Algorithm}
\begin{frame}
A \emph{cut} of a graph is a partition of its vertices into two nonempty disjoint sets

\bigskip

A \emph{crossing edge} of a cut is an edge that connects a vertex in one set with a vertex in the other

\bigskip

Cut property: given any cut, a crossing edge of minimum weight is in the MST

\begin{center}
\includegraphics[scale=0.4]{./figures/mst2.png}

\smallskip

\tiny cut property
\end{center}
\end{frame}

\begin{frame}[fragile]
\begin{minipage}{200pt}
Greedy MST algorithm
\begin{itemize}
\item Start with all edges colored gray

\item Find cut with no black edges and color its minimum-weight edge black

\item Repeat until $V - 1$ edges are colored black
\end{itemize}

\bigskip

The greedy algorithm computes the MST

\bigskip

Kruskal's and Prim's algorithms that we will encounter later choose cuts and minimum-weight edges efficiently
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{./figures/mst3.png}

\smallskip

\tiny trace of greedy MST algorithm
\end{center}
\end{minipage}
\end{frame}

\section{Kruskal's Algorithm}
\begin{frame}[fragile]
\begin{minipage}{240pt}
Add edges to tree $T$ in ascending order of weight unless doing so would create a cycle
\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class KruskalMST {
    private double weight;  
    private LinkedQueue<Edge> mst;
    
    public KruskalMST(EdgeWeightedGraph G) {
        mst =  new LinkedQueue<Edge>();  
        MinPQ<Edge> pq = new MinPQ<Edge>();
        for (Edge e : G.edges()) { pq.insert(e); }
        WeightedQuickUnionUF uf = 
            new WeightedQuickUnionUF(G.V());
        while (!pq.isEmpty() && mst.size() < G.V() - 1) {
            Edge e = pq.delMin();
            int v = e.either();
            int w = e.other(v);
            if (!uf.connected(v, w)) { 
                uf.union(v, w); 
                mst.enqueue(e); 
                weight += e.weight();
            }
        }
    }

    public Iterable<Edge> edges() { return mst; }

    public double weight() { return weight; }
    ...
}
\end{lstlisting}

Kruskal's algorithm computes MST in time proportional to
$E \log E$ in the worst case
\end{minipage}%
\begin{minipage}{100pt}
\begin{center}
\includegraphics[scale=0.4]{./figures/mst4.png}

\smallskip

\tiny trace of Kruskal's algorithm
\end{center}
\end{minipage}
\end{frame}

\section{Prim's Algorithm}
\begin{frame}[fragile]
Approach
\begin{itemize}
\item Start with vertex 0 and greedily grow tree $T$

\item Add to $T$ the minimum-weight edge with exactly one endpoint in $T$

\item Repeat until $V - 1$ edges have been added
\end{itemize}

\bigskip

Challenge: find the minimum-weight edge with exactly one endpoint in $T$
\end{frame}

\begin{frame}[fragile]
Lazy approach: maintain a priority queue (PQ) of edges with (at least) one endpoint in $T$
\begin{itemize}
\item Key = edge; priority = weight of edge

\item Delete minimum to determine next edge $e$ = $v$-$w$ to add to $T$

\item Disregard if both endpoints $v$ and $w$ are marked (both in $T$)

\item Otherwise, let $w$ be the unmarked vertex (not in $T$)
\begin{itemize}
\item Add to PQ any edge incident to $w$ (assuming other endpoint not in $T$)
\item Add $e$ to $T$ and mark $w$
\end{itemize}
\end{itemize}

\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class LazyPrimMST {
    private double weight; 
    private LinkedQueue<Edge> mst; 
    private boolean[] marked; 
    private MinPQ<Edge> pq; 

    public LazyPrimMST(EdgeWeightedGraph G) {
        mst = new LinkedQueue<Edge>();
        pq = new MinPQ<Edge>();
        marked = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) { prim(G, v); }  
        }  
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{minipage}{240pt}
\begin{lstlisting}[language=Java]
   private void prim(EdgeWeightedGraph G, int s) {
        scan(G, s);
        while (!pq.isEmpty()) { 
            Edge e = pq.delMin(); 
            int v = e.either(), w = e.other(v);  
            if (marked[v] && marked[w]) { continue; }  
            mst.enqueue(e); 
            weight += e.weight();
            if (!marked[v]) { scan(G, v); }  
            if (!marked[w]) { scan(G, w); } 
        }
    }

    private void scan(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        for (Edge e : G.adj(v)) {
            if (!marked[e.other(v)]) { pq.insert(e); }
        }
    }
    
    public Iterable<Edge> edges() { return mst; }

    public double weight() { return weight; }
    ...
}
\end{lstlisting}

Lazy Prim's algorithm computes the MST in time proportional
to $E \log E$ in the worst case
\end{minipage}%
\begin{minipage}{90pt}
\begin{center}
\includegraphics[scale=0.4]{./figures/mst5.png}

\smallskip

\tiny trace of Prims's algorithm (lazy approach)
\end{center}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
Eager approach: maintain a PQ of vertices connected by an edge to $T$, where priority of vertex $v$ = weight of shortest edge connecting $v$ to $T$
\begin{itemize}
\item Delete minimum vertex $v$ and add its associated edge $e$ = $v$-$w$ to $T$ 

\item Update PQ by considering all edges $e$ = $v$-$x$ incident to $v$

\begin{itemize}
\item Ignore if $x$ is already in $T$

\item Add $x$ to PQ if not already on it

\item Decrease priority of $x$ if $v$-$x$ becomes shortest edge connecting $x$ to $T$
\end{itemize}
\end{itemize}

\begin{lstlisting}[language=Java]
package edu.princeton.cs.algs4;

public class PrimMST {
    private Edge[] edgeTo; 
    private double[] distTo; 
    private boolean[] marked; 
    private IndexMinPQ<Double> pq;

    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];
        pq = new IndexMinPQ<Double>(G.V());
        for (int v = 0; v < G.V(); v++) { 
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) { prim(G, v); }
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{lstlisting}[language=Java]
    private void prim(EdgeWeightedGraph G, int s) {
        distTo[s] = 0.0;
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            scan(G, v);
        }
    }

    private void scan(EdgeWeightedGraph G, int v) {
        marked[v] = true;
        for (Edge e : G.adj(v)) {
            int w = e.other(v);
            if (marked[w]) { continue; }
            if (e.weight() < distTo[w]) {
                distTo[w] = e.weight();
                edgeTo[w] = e;
                if (pq.contains(w)) { pq.decreaseKey(w, distTo[w]); }
                else                { pq.insert(w, distTo[w]); }
            }
        }
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{minipage}{240pt}
\begin{lstlisting}[language=Java]
    public Iterable<Edge> edges() {
        LinkedQueue<Edge> mst = new LinkedQueue<Edge>();
        for (int v = 0; v < edgeTo.length; v++) {
            Edge e = edgeTo[v];
            if (e != null) { 
                mst.enqueue(e); 
            }
        }
        return mst;
    }

    public double weight() {
        double weight = 0.0;
        for (Edge e : edges()) { 
            weight += e.weight(); 
        }
        return weight;
    }
    ...
}
\end{lstlisting}

A binary heap based implementation of eager Prim's algorithm computes the MST in time proportional to $E \log V$ in the worst case
\end{minipage}%
\begin{minipage}{90pt}
\begin{center}
\includegraphics[scale=0.4]{./figures/mst6.png}

\smallskip

\tiny trace of Prims's algorithm (eager approach)
\end{center}
\end{minipage}
\end{frame}
\end{document}
